# 框架/库

> 记录一些框架、库的学习随记 📚

软件架构设计里面**最基础的概念“拆分”和“合并”**，`拆分`的意义是“分而治之”，将复杂问题拆分成单一问题解决，比如后端业务系统的”微服务化“设计；`合并`的意义是将同样的业务需求抽象收敛到一块，达成高效率高质量的目的，例如后端业务系统中的“中台服务”设计。

## 前端架构风格

> 所谓软件架构风格，是指描述某个特定应用领域中系统组织方式的惯用模式 🍹

### 分层架构

一个分层系统是按照层次来组织的，每一层为在其之上的层提供服务，并且使用在其之下的层所提供的服务。

- **是隔离业务复杂度与技术复杂度的利器**。 典型的例子是网络协议, 越高层越面向人类，越底层越面向机器
- **分离关注点和复用**。减少跨越多层的耦合, 当一层变动时不会影响到其他层。 例如前端项目建议拆分逻辑层和视图层，一方面可以降低逻辑和视图之间的耦合，当视图层元素变动时可以尽量减少对逻辑层的影响；另外一个好处是, 当逻辑抽取出去后，可以被不同平台的视图复用。
- 分层的抽象可能会丢失部分效率和灵活性

#### Virtual DOM

> 避免直接去频繁的操作DOM，导致大量的reflow, 影响性能

React就搞了一层VirtualDOM。 所谓的VirtualDOM，也就是虚拟节点。它通过 JS 的 Object 对象模拟 DOM 中的节点，然后再通过特定的 render 方法将其渲染成真实的 DOM 节点

所以说 VirtualDOM 更大的意义在于开发方式的转变: 声明式、数据驱动, 让开发者不需要关心 DOM 的操作细节 (属性操作、事件绑定、DOM 节点变更) ，另外有了VirtualDOM这一层抽象层，使得多平台渲染成为可能。

#### 多端统一开发框架

chameleon、Taro、uni-app、mpvue、WePY等

通过定义统一的语言框架 + 统一多态协议，从多端（对应多个独立服务）业务中抽离出自成体系、连续性强、可维护强的“前端中台服务”。

### 管道、过滤器

在管道/过滤器架构风格中，每个组件都有一组输入和输出，每个组件职责都很单一，数据输入组件，经过内部处理，然后将处理过的数据输出。所以这些组件也称为过滤器，连接器按照业务需求将组件连接起来，其形状就像管道一样，这种架构风格由此得名。

Rxjs 、 Gulp 、koa2/express中间件 、 webpack的loader对模块处理等

```js
import { fromEvent } from 'rxjs';
import { throttleTime, map, scan } from 'rxjs/operators';

fromEvent(document, 'click')
  .pipe(
    throttleTime(1000),
    map(event => event.clientX),
    scan((count, clientX) => count + clientX, 0)
  )
  .subscribe(count => console.log(count));

```

### 事件驱动

事件驱动编程最好的方法论是`发布订阅模式`。这样就分离了关注点，订阅者依赖于事件而不是依赖于发布者，发布者也不需要关心订阅者，两者解除了耦合。
解除耦合目的是一方面, 另一方面也可能由基因决定的，一些事情天然就不适合或不支持用同步的方式去调用，或者这些行为是异步触发的。

Node.js事件驱动模型

### 复制风格

基于复制(Replication)风格的系统，会利用多个实例提供相同的服务，来改善服务的可访问性和可伸缩性，以及性能。这种架构风格可以改善用户可察觉的性能，简单服务响应的延迟。

`利用多核能力`可以提升应用的性能和可靠性。我们也可以利用PM2这样的进程管理工具，来简化Node集群的管理，它支持很多有用的特性，例如集群节点重启、日志归集、性能监视等。
`复制风格常用于网络服务器`。浏览器和Node都有Worker的概念，但是一般都只推荐在CPU密集型的场景使用它们，因为浏览器或者NodeJS内置的异步操作已经非常高效

### 微内核架构

> 微核架构（microkernel architecture）又称为`插件架构`（plug-in architecture），指的是软件的内核相对较小，主要功能和业务逻辑都通过插件实现。

`内核（core）`通常只包含系统运行的最小功能。`插件`则是互相独立的，插件之间的通信，应该减少到最低，避免出现互相依赖的问题。微内核结构的难点在于建立一套粒度合适的插件协议、以及对插件之间进行适当的隔离和解耦。从而才能保证良好的扩展性、灵活性和可迁移性。
前端领域比较典型的例子是`Webpack、Babel、PostCSS以及ESLint`, 这些应用需要应对复杂的定制需求，而且这些需求时刻在变，只有微内核架构才能保证灵活和可扩展性。

`Webpack`的核心是一个`Compiler`，这个`Compiler`主要功能是集成`插件系统`、维护模块对象图, 对于模块代码具体编译工作、模块的打包、优化、分析、聚合统统都是基于外部插件完成的.
如上文说的`Loader`运用了`管道模式`，负责对源文件进行转译；那`Plugin`则可以将行为注入到`Compiler`运行的整个`生命周期`的`钩子`中, 完全访问`Compiler`的当前状态。

### 微前端

> 微前端旨在将单体前端分解成更小、更简单的模块，这些模块可以被独立的团队进行开发、测试和部署，最后再组合成一个大型的整体。

微前端的实施还需要有稳固的前端基础设施和研发体系的支撑

### 组件化

> 在给定的软件系统中，基于组件的架构侧重于对广泛使用的功能进行`关注点分离`。即将不同的复杂性、关注点分离出来，分别进行处理，让每一小部分都拥有自己的关注焦点。通过`定义、实现松散耦合的独立组件`，将其组合到系统中，以降低整个系统的复杂度。

组件化具有一系列的优点：可重用、代码简洁、易测试等。
组件的发展过程：

- 风格指南(Style Guide)对设计的文字、颜色、LOGO、ICON等设计做出规范，产出物一般为Guidline，Guidline一般为UI的规范。
- 模式库(Pattern Library)即UI组件库。模式库更侧重于前端开发，对界面元素的样式进行实现，其代码可供预览使用，产出物一般为组件库UI框架等，如Bootstrap库。
- 设计系统(Design System)设计系统在某种程度上结合了风格指南和模式库，并附加了一些业务特定的元素，并且进一步完善了组件化到页面模板相关的内容。

### 其他

- 面向对象风格:将应用或系统任务分割为单独、可复用、可自给的对象，每个对象都包含数据、以及对象相关的行为
- C/S:客户端/服务器风格
- 面向服务架构(SOA):指那些利用契约和消息将功能暴露为服务、消费功能服务的应用
- N层/三层:和分层架构差不多，侧重物理层. 例如C/S风格就是一个典型的N层架构
- 点对点风格
- 微服务架构
- 云架构
